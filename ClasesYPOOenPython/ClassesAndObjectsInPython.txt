				POO EN PYTHON - TUTORIAL BY CLEARCODE

Source: https://www.youtube.com/watch?v=_vr5faCXFo8

				¿QUE ES UN OBJETO?

Un object podría decirse que es sólo un contenedor para variables(propiedades,atributos) y funciones(comportamientos como atacar,moverse,...)

Es totalmente posible tener varios objetos,cada uno con valores diferentes para sus propiedades,pero los métodos si que serán los mismos,ya que son objetos de una misma clase y comparten comportamiento.Sin embargo,cada método está ligado al objeto,y puede recibir argumentos con valores diferentes por cada objeto.Si que serán los mismos,pero se comportarán diferente también.
Asi pues,cada objeto es totalmente diferente en comportamiento y valores.

Además,cada objeto puede interactuar con otro objeto.Todo esto son las bases de la POO,hoy en dia es indispensable conocerla.

				OBJETS AS PROPERTIES OF ANOTHER OBJECT

TIP: un objeto puede tener una propiedad que sea otro objeto.Este concepto es clave para crear código mantenible y escalable:

class Menu():
  player = Player() <- la clase Menu tiene la propiedad player de tipo Player(la cual es un objeto y me da un total control sobre las clases Menu y Player

				¿QUE ES UNA CLASE?

Un clase,por el contrario,es el plano para crear objetos.Siempre que quiera crear un objeto,necesitaré una Clase.
Una clase también acepta argumentos para customizar el objeto que crea.Por ejemplo,podría establecer la health y energy de cada Monster:

class Monster():
  def __init__(self,health,energy):
    self.health = health
    self.energy = energy
  def attack(self):
    pass
  def move(self):
    pass

Ahora,al crear un objeto de clase Monster le puedo pasar valores:
monster1 = Monster(100,20)
monster2 = Monster(90,15)

Una clase también puede heredar de otra.Los objetos creados de esta clase tendrán los atributos y métodos de las dos clases.
Usar POO me permite organizar código complejo,además de hacerlo reusable.Además,muchas librerias me obligarán a usar clases.También me permiten cambiar el scope de propiedades o métodos,lo cual es muchas veces obligatorio o simplemente conveniente.

				__DUNDER__ METHODS - DOUBLE UNDERSCORE METHODS

Ojo,dunder stands for DoubleUNDERscore,es la unión de la D y de UNDER,no tiene nada que ver con la palabra DUNDER.Cualquier método que use dobles guiones bajos es un DUNDER METHOD.
IMPORTANTE: un Dunder Method es un método que no es callable por el user,sino que lo llama el programa cuando suceda algo en concreto(siempre habrá un disparador pues del dunder method).Por ejemplo:
__init__ : es llamado cuando un objeto es construido
__len__: es llamado cuando el objeto es pasado a la funcion len()
__abs__: es llamado cuando un objeto es pasado a la función abs()
Realmente no es nada complejo esto.Obviamente el más usado es __init__

NOTA: normalmente las clases no llevan atributos en Python,sino que los lleva el constructor mediante el dunde __init__.Interesante.

# con este dunder puedo sobrescribir lo que devuelva la ejecución de len()
  def __len__(self):
    return 53

# dado que sobreescribí el dunder __len__ dará 53
print(len(monster_01)) <- obviamente devuelve 53

IMPORTANTE: puedo ver todos los dunder methods que tiene un objeto usando el método dir.Esto es aplicable a todo objeto y realmente útil.Además,despues de los dunder también dice los campos de clase:

print(dir(monster_01))
['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__len__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'attack', 'energy', 'health', 'move', 'name']

Fijate como tengo varios,incluso tengo __dir__ para poder sobrescribir esto jaja.El dunder __eq__ o __dict__ son muy interesantes
Incluso hay un dunder para poder ejecutar una instancia como si fuera un método:
def __call__(self):
  print('The monster was called')

monster_01() <- fijate que estoy llamando a la instancia con ()

Lo mismo para __add__:
# puedo sobrescribir lo que hará sumar algo sobre el objeto
  def __add__(self,other):
    return f'the monster healths in {other} quantity.Now is health is {self.health + other}'

IMPORTANTE: obviamente los más usados son __init__ y __str__ ,el cual en teoria imprime info sobre el objeto de una forma presentable(a no ser que se sobrescriba,claro):

 def __str__(self):
    return f'Hi!: I am the monster {self.name} with {self.health} of health'

Igual que en Java,por defecto se llama a éste método:
print(monster_01)
Aunque también lo puedo usar:
print(str(monster_01))
Sin sobrescribirlo da la dirección a memoria,que realmente no me vale para mucho.

						CLASSES IN DEEP

En Python todo es un object(y en Ruby),incluido los inbuilt strings,los integers,incluso las funciones son objetos(con lo que serán instancias de una clase Function o algo)
Recuerda también que un método pertenece a un objeto(da igual si el objeto lo creó Python)
Con todo esto en mente,en Python puedo hacer cosas como:
'casa'.upper() <- llamar a un método sobre el string inmediatamente(ya que es un object)
len('test') | len([1,2,3]) | len({a:1,b:2}) | len((1,3,2)) <- llamar a un método casi con cualquier tipo de objeto,ya que todo es un object
NOTA: (1,2,3) es una tupla y [1,2,3] es una lista.
En Python está el unpacking(destructuring de JS):
(a,b,c) = ('asinto','perez','alonso') 

Destacar también que en Python puedo almacenar en una variable/propiedad un método(ya que el método es un objeto).Esto me permite almacsenar en una propieda un método de otra clase:

# create a Monster class with a parameter called func,
class Monster:
    def __init__(self, func):
        self.func = func

# create a class called Attacks,that has 4 methods: bite,strike,slash and kick(they just print some str)
class Attacks:
    def bite(self):
        print('bitting...')
    def strike(self):
        print('striking...')
    def slash(self):
        print('slashing...')
    def kick(self):
        print('kicking...')

attacks = Attacks()
# fijate como acepta cualquier cosa como parametro de clase Python
monster = Monster(attacks.bite)
# realmente no tengo porque instanciar Attacks,lo puedo pasar a un Objeto llamando,ya que una Class tiene el método __call__
monster2 = Monster(Attacks().bite) # forma PRO TOTAL
# y llamo al método,muy asinto todo
monster.func()

Fijate en la forma PRO de pasar una clase a objeto simplemente llamandola,ya que tiene el dunder __call__ por ser una Class.

					CLASSES AND THE SCOPE OF THEM

Todo método tiene una referencia a la clase donde vive.Por ello es muy fácil obtener y cambiar atributos de clase(getter an setters)
Minuto 59
